definition
module Scala-Whitespace

exports

lexical syntax
[\ \t\n\r]       -> LAYOUT
"//" ~[\n]* [\n] -> LAYOUT
BLOCK-COMMENT    -> LAYOUT

"/*" BLOCK-COMMENT-PART* "*/" -> BLOCK-COMMENT
~[\/\*]       -> BLOCK-COMMENT-PART
ASTERISK      -> BLOCK-COMMENT-PART
SLASH         -> BLOCK-COMMENT-PART
BLOCK-COMMENT -> BLOCK-COMMENT-PART

    -> EOL
    -> EOF
    -> EOB
    -> EOP
";" -> SEMI

[\n] -> NL
[\*] -> ASTERISK
[\/] -> SLASH

lexical restrictions
ASTERISK -/- [\/]
SLASH    -/- [\*]

context-free restrictions
LAYOUT? -/- [\ \t\n\r]
LAYOUT? -/- [\/].[\*]
LAYOUT? -/- [\/].[\/]
EOF -/- ~[]
EOB -/- ~[\}]
EOP -/- ~[\)]

module Scala-Types

imports
Scala-Annotations
Scala-BasicDeclsDefs
Scala-Identifiers
Scala-Whitespace

exports

%% §3.1 Paths
context-free syntax
Id              -> Path                                                 {prefer}
{PathElem "."}+ -> Path                                                 {cons("Path")}

PLAIN-ID                              -> PathElem
"this"                                -> PathElem                       {cons("This")}
"super" ClassQualifier? "." PLAIN-ID  -> PathElem                      {cons("Super")}

PLAIN-ID                -> StableIdElem
"this"                  -> StableIdElem                           {cons("StableThis")}
"super" ClassQualifier? -> StableIdElem                          {cons("StableSuper")}

Id                               -> StableId
{StableIdElem "."}+ "." PLAIN-ID -> StableId                        {cons("StableId")}

"[" PLAIN-ID "]" -> ClassQualifier                            {cons("ClassQualifier")}

PREFIX -> Path {reject} %% not 100% sure this is correct

context-free restrictions
StableId -/- [\.] . [\33-\126] / [\{\,\_]


%% §3.2 - Value Types
context-free syntax
%% §3.2.1 - Singleton Types
Path "." "type"     -> SimpleType                              {cons("SingletonType")}

%% §3.2.2 - Type Projection
SimpleType "#" Id   -> SimpleType                             {cons("TypeProjection")}

%% §3.2.3 - Type Designators
StableId            -> SimpleType                                       {cons("Type")}

%% §3.2.4 - Parameterized Types
SimpleType TypeArgs -> SimpleType                          {cons("ParameterizedType")}
"[" {Type ","}+ "]" -> TypeArgs                                     {cons("TypeArgs")}

%% §3.2.5 - Tuple Types
"(" {Type ","}+ ")" -> SimpleType                                  {cons("TupleType")}

%% §3.2.6 - Annotated Types
SimpleType             -> AnnotType
SimpleType Annotation+ -> AnnotType                                {cons("AnnotType"),
                                          layout("1.last.line == 2.first.line")}

%% §3.2.7 - Compound Types
AnnotType                   -> CompoundType
Refinement                  -> CompoundType
AnnotType Refinement        -> CompoundType                      {cons("RefinedType")}
AnnotType With+ Refinement? -> CompoundType                      {cons("CompoundType"),
                                  layout("3.first.line - 2.last.line < num(2)")}

"with" AnnotType -> With                                                {cons("With")}

"{" RefineStatSemi* "}" -> Refinement                             {cons("Refinement")}

RefineStat EOL  -> RefineStatSemi                             {cons("RefineStatSemi"),
                                         enforce-newline, longest-match, prefer}
RefineStat SEMI -> RefineStatSemi              {longest-match, cons("RefineStatSemi")}
RefineStat EOB  -> RefineStatSemi       {longest-match, avoid, cons("RefineStatSemi")}

Dcl            -> RefineStat
"type" TypeDef -> RefineStat                                  {cons("TypeRefineStat")}

%% §3.2.8 - Infix Types
InfixType -> Type

CompoundType                 -> InfixType
InfixType PLAIN-ID InfixType -> InfixType                    {left, cons("InfixType"),
                                  layout("3.first.line - 2.last.line < num(2)")}

%% §3.2.9 - Function Types
FunctionArgTypes "=>" Type  -> Type                     {prefer, cons("FunctionType")}

InfixType                -> FunctionArgTypes
"(" {ParamType ","}* ")" -> FunctionArgTypes         {prefer, cons("FunctionArgType")}

%% §3.2.10 - Existential Types
InfixType ExistentialClause -> Type {cons("ExistentialType")}

"forSome" "{" ExistentialDclSemi+ "}" -> ExistentialClause {cons("ExistentialClause")}

ExistentialDcl SEMI -> ExistentialDclSemi  {longest-match, cons("ExistentialDclSemi")}
ExistentialDcl EOL  -> ExistentialDclSemi                 {cons("ExistentialDclSemi"),
                                         enforce-newline, longest-match, prefer}
ExistentialDcl EOB  -> ExistentialDclSemi  {longest-match, cons("ExistentialDclSemi")}

"type" TypeDcl -> ExistentialDcl                             {cons("ExistentialType")}
"val"  ValDcl  -> ExistentialDcl                              {cons("ExistentialVal")}

"_" TypeBounds?     -> SimpleType                        {avoid, cons("WildcardType")}

">:" Type           -> TypeBounds                             {cons("LowerTypeBound")}
"<:" Type           -> TypeBounds                             {cons("UpperTypeBound")}
">:" Type "<:" Type -> TypeBounds                     {cons("LowerAndUpperTypeBound")}

module Scala-TopLevelDefinitions

imports
Scala-BasicDeclsDefs
Scala-ClassesObjects
Scala-Identifiers
Scala-Whitespace

exports

context-free syntax
-> CompilationUnit                                      {cons("EmptyCompilationUnit")}
PackageDeclarationSemi* TopStatSemi+ -> CompilationUnit      {cons("CompilationUnit")}

TopStat EOL  -> TopStatSemi                                      {cons("TopStatSemi"),
                                         enforce-newline, longest-match, prefer}
TopStat SEMI -> TopStatSemi                                      {cons("TopStatSemi")}
TopStat EOF  -> TopStatSemi                       {longest-match, cons("TopStatSemi")}
TopStat EOB  -> TopStatSemi                {longest-match, avoid, cons("TopStatSemi")}

AnnotationSeq? Modifier* TmplDef -> TopStat                       {cons("TopTmplDef")}
Import                           -> TopStat
Packaging                        -> TopStat
PackageObject                    -> TopStat

"package" QualId EOL  -> PackageDeclarationSemi           {cons("PackageDeclaration"),
                                                                enforce-newline}
"package" QualId SEMI -> PackageDeclarationSemi           {cons("PackageDeclaration")}

{Id "."}+ -> QualId                                                   {cons("QualId")}

"package" QualId "{" TopStatSemi+ "}" -> Packaging                 {cons("Packaging"),
                                  layout("3.first.line - 2.last.line < num(2)")}

"package" "object" ObjectDef -> PackageObject                  {cons("PackageObject")}

module Scala-PatternMatching

imports
Scala-Literals
Scala-Types

exports

lexical syntax
PLAIN-ID -> INFIX-PATTERN-OP
"|"      -> INFIX-PATTERN-OP                                            {reject}

context-free priorities
{
  "_"                                    -> SimplePattern    {cons("WildcardPattern")}
%%VarId                                  -> SimplePattern    {"VariablePattern"}
  Literal                                -> SimplePattern     {cons("LiteralPattern")}
  StableId "(" Patterns ")"              -> SimplePattern {cons("ConstructorPattern")}
  "(" Patterns ")"                       -> SimplePattern       {cons("TuplePattern")}
  StableId "(" (Patterns ",")? (VAR-PLAIN-ID "@")? "_" "*" ")"
                                         -> SimplePattern    {cons("PatternSequence")}
  StableId                               -> SimplePattern
}

> {
  Pattern3 INFIX-PATTERN-OP Pattern3 -> Pattern3          {left, cons("InfixPattern"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
  SimplePattern                      -> Pattern3
}

> {
  VAR-PLAIN-ID "@" Pattern3 -> Pattern2                        {cons("PatternBinder")}
  Pattern3                  -> Pattern2
}

> {
  VAR-PLAIN-ID ":" Type -> Pattern1                             {cons("TypedPattern")}
  "_" ":" Type          -> Pattern1                     {cons("WildcardTypedPattern")}
  Pattern2              -> Pattern1
}

> {
  Pattern1            -> Pattern                                 {longest-match}
  Pattern "|" Pattern -> Pattern                       {cons("DisjunctPattern"), left}
}

context-free syntax
{Pattern ","}* -> Patterns {cons("Patterns")}

%%% Repeat priorities in context-free syntax for correct PPTable generation %%%
context-free syntax
"_"                                  -> SimplePattern        {cons("WildcardPattern")}
Literal                              -> SimplePattern         {cons("LiteralPattern")}
StableId "(" Patterns ")"            -> SimplePattern     {cons("ConstructorPattern")}
"(" Patterns ")"                     -> SimplePattern           {cons("TuplePattern")}
StableId "(" (Patterns ",")?
  (VAR-PLAIN-ID "@")? "_" "*" ")"    -> SimplePattern        {cons("PatternSequence")}
Pattern3 INFIX-PATTERN-OP Pattern3   -> Pattern3          {left, cons("InfixPattern"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
VAR-PLAIN-ID "@" Pattern3            -> Pattern2               {cons("PatternBinder")}
VAR-PLAIN-ID ":" Type                -> Pattern1                {cons("TypedPattern")}
"_" ":" Type                         -> Pattern1        {cons("WildcardTypedPattern")}
Pattern "|" Pattern                  -> Pattern        {left, cons("DisjunctPattern")}

module Scala-Macros

imports
Scala-BasicDeclsDefs
Scala-Identifiers
Scala-Types

exports

context-free syntax
FunSig (":" Type)? "=" "macro" StableId TypeArgs?         -> FunDef {cons("MacroDef")}

module Scala-Literals

imports
Scala-Identifiers

exports

lexical syntax
DECIMAL-NUMERAL ("L" | "l")? -> INTEGER
HEX-NUMERAL ("L" | "l")?     -> INTEGER
OCTAL-NUMERAL ("L" | "l")?   -> INTEGER                                 {prefer}
"-" INTEGER                  -> INTEGER

[0] | NON-ZERO-DIGIT DIGIT* -> DECIMAL-NUMERAL
"0x" HEX-DIGIT+             -> HEX-NUMERAL
[0] OCTAL-DIGIT+            -> OCTAL-NUMERAL
[0-9]       -> DIGIT
[1-9]       -> NON-ZERO-DIGIT
[0-7]       -> OCTAL-DIGIT
[0-9A-Fa-f] -> HEX-DIGIT

DIGIT+ "." DIGIT+ EXPONENT-PART? FLOAT-TYPE? -> FLOATING-POINT
"." DIGIT+ EXPONENT-PART? FLOAT-TYPE?        -> FLOATING-POINT
DIGIT+ EXPONENT-PART                         -> FLOATING-POINT
DIGIT+ FLOAT-TYPE                            -> FLOATING-POINT
DIGIT+ EXPONENT-PART FLOAT-TYPE              -> FLOATING-POINT
"-" FLOATING-POINT                           -> FLOATING-POINT

("E" | "e") ("+" | "-")? DIGIT+ -> EXPONENT-PART
"F" | "f" | "D" | "d"           -> FLOAT-TYPE

"'" PRINTABLE "'"       -> CHAR
"'" CHAR-ESCAPE-SEQ "'" -> CHAR

[\32-\126]        -> PRINTABLE
[\0-\127] / [\"]  -> CHAR-NO-DOUBLE-QUOTE

"\\b" | "\\t" | "\\n" | "\\f" |
"\\r" | "\\\"" | "\\'" | "\\\\" -> CHAR-ESCAPE-SEQ
"\\" [0-1]? [0-9]? [0-9]        -> CHAR-ESCAPE-SEQ
"\\" DIGIT? DIGIT? DIGIT        -> CHAR-ESCAPE-SEQ
UNICODE-ESCAPE                  -> CHAR-ESCAPE-SEQ

"\\" "u" HEX-DIGIT HEX-DIGIT HEX-DIGIT HEX-DIGIT -> UNICODE-ESCAPE

"\"" STRING-ELEMENT* "\""          -> STRING
"\"\"\"" MULTI-LINE-CHARS "\"\"\"" -> STRING

[\32-\126] / [\"\\]   -> STRING-ELEMENT
CHAR-ESCAPE-SEQ       -> STRING-ELEMENT

PLAIN-ID "\"" PROCESSED-STRING-ELEMENT* "\""                 -> PROCESSED-STRING
PLAIN-ID "\"\"\"" MULTI-LINE-PROCESSED-STRING-ELEMENT "\"\"\""
                                                             -> PROCESSED-STRING


[\32-\126] / [\"\$\\] -> PROCESSED-STRING-ELEMENT
CHAR-ESCAPE-SEQ       -> PROCESSED-STRING-ELEMENT
PROCESSING            -> PROCESSED-STRING-ELEMENT

"$$"                         -> PROCESSING
"${" PROCESSING-ELEMENT* "}" -> PROCESSING
"$" IPLAIN-ID                -> PROCESSING

"{" PROCESSING-ELEMENT* "}" -> PROCESSING-ELEMENT
[\0-\127] / [\{\}\"]        -> PROCESSING-ELEMENT
PROCESSED-STRING            -> PROCESSING-ELEMENT
STRING                      -> PROCESSING-ELEMENT

([\"]? [\"]? CHAR-NO-DOUBLE-QUOTE)* [\"]* -> MULTI-LINE-CHARS

([\"]? [\"]? IMULTI-LINE-PROCESSED-STRING-ELEMENT)* [\"]*
                                          -> MULTI-LINE-PROCESSED-STRING-ELEMENT

PROCESSING         -> IMULTI-LINE-PROCESSED-STRING-ELEMENT
[\0-\127] / [\"\$] -> IMULTI-LINE-PROCESSED-STRING-ELEMENT

[\"]      -> DOUBLE-QUOTE
[\"] [\"] -> DOUBLE-DOUBLE-QUOTE

"'" IPLAIN-ID -> SYMBOL

lexical restrictions
INTEGER        -/- [0-9a-zA-Z]
FLOATING-POINT -/- [0-9a-zA-Z]
Literal        -/- [0-9a-zA-Z]
"true"         -/- [0-9a-zA-Z]
"false"        -/- [0-9a-zA-Z]
DOUBLE-QUOTE        -/- [\"]
DOUBLE-DOUBLE-QUOTE -/- [\"]

context-free syntax
INTEGER          -> Literal                                              {cons("Int")}
FLOATING-POINT   -> Literal                                            {cons("Float")}
CHAR             -> Literal                                             {cons("Char")}
STRING           -> Literal                                           {cons("String")}
SYMBOL           -> Literal                                           {cons("Symbol")}
"null"           -> Literal                                             {cons("Null")}
PROCESSED-STRING -> Literal                                  {cons("ProcessedString")}
BooleanLiteral   -> Literal

"true"  -> BooleanLiteral                                               {cons("True")}
"false" -> BooleanLiteral                                              {cons("False")}

module Scala-Identifiers

exports

lexical syntax
[A-Z] | [\$]   -> UPPER
[a-z]          -> LOWER
UPPER | LOWER  -> LETTER
[0-9]          -> DIGIT
LETTER | DIGIT -> ID-REST

[\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~] -> OP-CHAR

%% OPerators by precedence from low to high
OP-CHAR* [\=]                 -> ASSIGN-OP
VAR-PLAIN-ID | CONST-PLAIN-ID -> LETTER-OP
[\|] OP-CHAR*                 -> BAR-OP
[\^] OP-CHAR*                 -> CIRCUMFLEX-OP
[\&] OP-CHAR*                 -> AMPERSAND-OP
([\<] | [\>]) OP-CHAR*        -> BRACKET-OP
([\=] | [\!]) OP-CHAR*        -> CMPR-OP
[\:] OP-CHAR*                 -> COLON-OP
([\+] | [\-]) OP-CHAR*        -> SUM-OP
([\*] | [\/] | [\%]) OP-CHAR* -> MULT-OP
[\#\?\@\\\~] OP-CHAR*         -> SPECIAL-OP

%% right associative operators
%% TODO: Make RASSOC-LETTER-OP actually work
%%       Won't do at the current state, as of restrictions on OP
(VAR-PLAIN-ID | CONST-PLAIN-ID) [\:] -> RASSOC-LETTER-OP
[\|] OP-CHAR* [\:]                   -> RASSOC-BAR-OP
[\^] OP-CHAR* [\:]                   -> RASSOC-CIRCUMFLEX-OP
[\&] OP-CHAR* [\:]                   -> RASSOC-AMPERSAND-OP
([\<] | [\>]) OP-CHAR* [\:]          -> RASSOC-BRACKET-OP
([\=] | [\!]) OP-CHAR* [\:]          -> RASSOC-CMPR-OP
[\:] OP-CHAR* [\:]                   -> RASSOC-COLON-OP
([\+] | [\-]) OP-CHAR* [\:]          -> RASSOC-SUM-OP
([\*] | [\/] | [\%]) OP-CHAR* [\:]   -> RASSOC-MULT-OP
[\#\?\@\\\~] OP-CHAR* [\:]           -> RASSOC-SPECIAL-OP

[\=] OP-CHAR* [\=] -> ASSIGN-OP {reject}
"="  -> ASSIGN-OP  {reject}
"<=" -> ASSIGN-OP  {reject}
">=" -> ASSIGN-OP  {reject}
"!=" -> ASSIGN-OP  {reject}
"="  -> CMPR-OP    {reject}
"=>" -> CMPR-OP    {reject}
":"  -> COLON-OP   {reject}
"<-" -> BRACKET-OP {reject}
"<:" -> BRACKET-OP {reject}
"<:" -> RASSOC-BRACKET-OP {reject}
"<%" -> BRACKET-OP {reject}
">:" -> BRACKET-OP {reject}
">:" -> RASSOC-BRACKET-OP {reject}
"#"  -> SPECIAL-OP {reject}
"@"  -> SPECIAL-OP {reject}

%% ASSIGN-OP is exception and thus more important than the other ops
ASSIGN-OP -> LETTER-OP     {reject}
ASSIGN-OP -> BAR-OP        {reject}
ASSIGN-OP -> CIRCUMFLEX-OP {reject}
ASSIGN-OP -> AMPERSAND-OP  {reject}
ASSIGN-OP -> BRACKET-OP    {reject}
ASSIGN-OP -> CMPR-OP       {reject}
ASSIGN-OP -> COLON-OP      {reject}
ASSIGN-OP -> SUM-OP        {reject}
ASSIGN-OP -> MULT-OP       {reject}
ASSIGN-OP -> SPECIAL-OP    {reject}

%% Right associative identifiers have higher priority than
%% their left associative counterparts
RASSOC-LETTER-OP     -> LETTER-OP     {reject}
RASSOC-BAR-OP        -> BAR-OP        {reject}
RASSOC-CIRCUMFLEX-OP -> CIRCUMFLEX-OP {reject}
RASSOC-AMPERSAND-OP  -> AMPERSAND-OP  {reject}
RASSOC-BRACKET-OP    -> BRACKET-OP    {reject}
RASSOC-CMPR-OP       -> CMPR-OP       {reject}
RASSOC-COLON-OP      -> COLON-OP      {reject}
RASSOC-SUM-OP        -> SUM-OP        {reject}
RASSOC-MULT-OP       -> MULT-OP       {reject}
RASSOC-SPECIAL-OP    -> SPECIAL-OP    {reject}

OP-CHAR+ -> OP

LOWER                           -> IVAR-ID
(IVAR-ID | IVAR-ID-USS) ID-REST -> IVAR-ID
(IVAR-ID | IVAR-ID-USS) [\_]    -> IVAR-ID-USS
IVAR-ID-USS OP                  -> IVAR-ID-OP

[\_]                                -> ICONST-ID
UPPER                               -> ICONST-ID
(ICONST-ID | ICONST-ID-USS) ID-REST -> ICONST-ID
(ICONST-ID | ICONST-ID-USS) [\_]    -> ICONST-ID-USS
ICONST-ID-USS [\_]                  -> ICONST-ID-USS
ICONST-ID-USS OP                    -> ICONST-ID-OP

IVAR-ID     -> VAR-ID
IVAR-ID-USS -> VAR-ID-USS
IVAR-ID-OP  -> VAR-ID-OP

ICONST-ID     -> CONST-ID
ICONST-ID-USS -> CONST-ID-USS
ICONST-ID-OP  -> CONST-ID-OP

(VAR-ID   | VAR-ID-USS   | VAR-ID-OP)   -> IVAR-PLAIN-ID
(CONST-ID | CONST-ID-USS | CONST-ID-OP) -> ICONST-PLAIN-ID

OP              -> IPLAIN-ID
IVAR-PLAIN-ID   -> IPLAIN-ID
ICONST-PLAIN-ID -> IPLAIN-ID

IVAR-PLAIN-ID   -> VAR-PLAIN-ID
ICONST-PLAIN-ID -> CONST-PLAIN-ID
IPLAIN-ID       -> PLAIN-ID

"abstract"  -> KEYWORD
"case"      -> KEYWORD
"catch"     -> KEYWORD
"class"     -> KEYWORD
"def"       -> KEYWORD
"do"        -> KEYWORD
"else"      -> KEYWORD
"extends"   -> KEYWORD
"false"     -> KEYWORD
"final"     -> KEYWORD
"finally"   -> KEYWORD
"for"       -> KEYWORD
"forSome"   -> KEYWORD
"if"        -> KEYWORD
"implicit"  -> KEYWORD
"import"    -> KEYWORD
"lazy"      -> KEYWORD
"macro"     -> KEYWORD
"match"     -> KEYWORD
"new"       -> KEYWORD
"null"      -> KEYWORD
"object"    -> KEYWORD
"override"  -> KEYWORD
"package"   -> KEYWORD
"private"   -> KEYWORD
"protected" -> KEYWORD
"return"    -> KEYWORD
"sealed"    -> KEYWORD
"super"     -> KEYWORD
"this"      -> KEYWORD
"throw"     -> KEYWORD
"trait"     -> KEYWORD
"try"       -> KEYWORD
"true"      -> KEYWORD
"type"      -> KEYWORD
"val"       -> KEYWORD
"var"       -> KEYWORD
"while"     -> KEYWORD
"with"      -> KEYWORD
"yield"     -> KEYWORD
"_"         -> KEYWORD
":"         -> KEYWORD
"="         -> KEYWORD
"=>"        -> KEYWORD
"<-"        -> KEYWORD
"<:"        -> KEYWORD
"<%"        -> KEYWORD
">:"        -> KEYWORD
"#"         -> KEYWORD
"@"         -> KEYWORD

KEYWORD  -> VAR-PLAIN-ID   {reject}
KEYWORD  -> CONST-PLAIN-ID {reject}
KEYWORD  -> PLAIN-ID       {reject}

"-"          -> MINUS-PREFIX
"+"          -> PREFIX
MINUS-PREFIX -> PREFIX
"~"          -> PREFIX
"!"          -> PREFIX

"`" ~[\`]+ "`" -> FANCY-ID
FANCY-ID       -> PLAIN-ID

lexical restrictions
OP -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]

ASSIGN-OP      -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
LETTER-OP      -/- [a-zA-Z0-9]
BAR-OP         -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
CIRCUMFLEX-OP  -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
AMPERSAND-OP   -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
BRACKET-OP     -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
CMPR-OP        -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
COLON-OP       -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
SUM-OP         -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
MULT-OP        -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
SPECIAL-OP     -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]

RASSOC-LETTER-OP      -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
RASSOC-BAR-OP         -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
RASSOC-CIRCUMFLEX-OP  -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
RASSOC-AMPERSAND-OP   -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
RASSOC-BRACKET-OP     -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
RASSOC-CMPR-OP        -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
RASSOC-COLON-OP       -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
RASSOC-SUM-OP         -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
RASSOC-MULT-OP        -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
RASSOC-SPECIAL-OP     -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]

VAR-ID   -/- [A-Za-z0-9\$\_]
CONST-ID -/- [A-Za-z0-9\$\_]

VAR-ID-USS   -/- [A-Za-z0-9\$\_] \/ [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
CONST-ID-USS -/- [A-Za-z0-9\$\_] \/ [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]

"abstract" -/- [a-zA-Z0-9\$\_]
"case"     -/- [a-zA-Z0-9\$\_]
"catch"    -/- [a-zA-Z0-9\$\_]
"class"    -/- [a-zA-Z0-9\$\_]
"def"      -/- [a-zA-Z0-9\$\_]
"do"       -/- [a-zA-Z0-9\$\_]
"else"     -/- [a-zA-Z0-9\$\_]
"extends"  -/- [a-zA-Z0-9\$\_]
"false"    -/- [a-zA-Z0-9\$\_]
"final"    -/- [a-zA-Z0-9\$\_]
"finally"  -/- [a-zA-Z0-9\$\_]
"for"      -/- [a-zA-Z0-9\$\_]
"forSome"  -/- [a-zA-Z0-9\$\_]
"if"       -/- [a-zA-Z0-9\$\_]
"implicit" -/- [a-zA-Z0-9\$\_]
"import"   -/- [a-zA-Z0-9\$\_]
"lazy"     -/- [a-zA-Z0-9\$\_]
"macro"    -/- [a-zA-Z0-9\$\_]
"match"    -/- [a-zA-Z0-9\$\_]
"new"      -/- [a-zA-Z0-9\$\_]
"null"     -/- [a-zA-Z0-9\$\_]
"object"   -/- [a-zA-Z0-9\$\_]
"override" -/- [a-zA-Z0-9\$\_]
"package"  -/- [a-zA-Z0-9\$\_]
"private"  -/- [a-zA-Z0-9\$\_]
"protected"-/- [a-zA-Z0-9\$\_]
"return"   -/- [a-zA-Z0-9\$\_]
"sealed"   -/- [a-zA-Z0-9\$\_]
"super"    -/- [a-zA-Z0-9\$\_]
"this"     -/- [a-zA-Z0-9\$\_]
"throw"    -/- [a-zA-Z0-9\$\_]
"trait"    -/- [a-zA-Z0-9\$\_]
"try"      -/- [a-zA-Z0-9\$\_]
"true"     -/- [a-zA-Z0-9\$\_]
"type"     -/- [a-zA-Z0-9\$\_]
"val"      -/- [a-zA-Z0-9\$\_]
"var"      -/- [a-zA-Z0-9\$\_]
"while"    -/- [a-zA-Z0-9\$\_]
"with"     -/- [a-zA-Z0-9\$\_]
"yield"    -/- [a-zA-Z0-9\$\_]

"=" -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
":" -/- [\!\#\%\&\*\+\-\/\:\<\=\>\?\@\\\^\|\~]
"_" -/- [a-zA-Z0-9\_\$]

PREFIX -/- [\+\-\~\!]
MINUS-PREFIX -/- [0-9]

FANCY-ID -/- [a-zA-Z0-9\_\$]

context-free syntax
PLAIN-ID -> Id {cons("Id")}

module Scala-Expressions

imports
Scala-Annotations
Scala-BasicDeclsDefs
Scala-ClassesObjects
Scala-Literals
Scala-PatternMatching
Scala-Types
Scala-Whitespace

exports

lexical syntax
-> EOC

context-free restrictions
EOC -/- ~[c]


%%%%% With Layout %%%%%%
context-free priorities
{
  Literal                -> Expr                                        {prefer}
  "_"                    -> Expr                                {cons("WildcardExpr")}
  Expr ArgumentExprs     -> Expr                                     {cons("AppExpr"),
                                          layout("1.last.line == 2.first.line")}
  Expr BlockExpr         -> Expr                                {cons("BlockAppExpr"),
                                  layout("2.first.line - 1.last.line < num(2)")}
  "(" {NoLExpr ","}* ")" -> Expr                                   {cons("TupleExpr")}
  Expr TypeArgs          -> Expr                             {cons("TypeApplication")}
  Path                   -> Expr
}

> {
  "new" ClassTemplate -> Expr                           {prefer, cons("NewClassExpr")}
  "new" TemplateBody  -> Expr                        {prefer, cons("NewTemplateExpr")}
  Expr "_"            -> Expr                         {left, cons("EtaExpansionExpr"),
                                          layout("1.last.line == 2.first.line")}
  BlockExpr           -> Expr
}

> PREFIX Expr             -> Expr                                 {cons("PrefixExpr"),
                                  prefer, layout("1.last.line == 2.first.line")}
> PREFIX Expr             -> Expr                                 {cons("PrefixExpr"),
                                  prefer, layout("1.last.line == 2.first.line")}
> {
  Expr SPECIAL-OP Expr        -> Expr                        {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
  Expr RASSOC-SPECIAL-OP Expr -> Expr                       {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
}
> {
  Expr MULT-OP Expr        -> Expr                           {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
  Expr RASSOC-MULT-OP Expr -> Expr                          {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
}
> {
  Expr SUM-OP Expr        -> Expr                            {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
  Expr RASSOC-SUM-OP Expr -> Expr                           {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
}
> {
  Expr COLON-OP Expr        -> Expr                          {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
  Expr RASSOC-COLON-OP Expr -> Expr                         {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
}
> {
  Expr CMPR-OP Expr        -> Expr                           {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
  Expr RASSOC-CMPR-OP Expr -> Expr                          {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
}
> {
  Expr BRACKET-OP Expr        -> Expr                        {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
  Expr RASSOC-BRACKET-OP Expr -> Expr                       {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
}
> {
  Expr AMPERSAND-OP Expr        -> Expr                      {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
  Expr RASSOC-AMPERSAND-OP Expr -> Expr                     {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
}
> {
  Expr CIRCUMFLEX-OP Expr        -> Expr                     {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
  Expr RASSOC-CIRCUMFLEX-OP Expr -> Expr                    {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
}
> {
  Expr BAR-OP Expr        -> Expr                            {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
  Expr RASSOC-BAR-OP Expr -> Expr                           {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
}
> {
  Expr LETTER-OP Expr        -> Expr                         {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
  Expr RASSOC-LETTER-OP Expr -> Expr                        {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
}
> Expr ASSIGN-OP Expr     -> Expr                            {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
> Expr Id -> Expr  {avoid, layout("1.last.line == 2.first.line"), cons("PostfixExpr")}
> Expr Id -> Expr  {avoid, layout("1.last.line == 2.first.line"), cons("PostfixExpr")}
> Expr "match" "{" CaseClause+ "}" -> Expr                         {cons("MatchExpr")}
> Expr ArgumentExprs "=" Expr -> Expr        {non-assoc, cons("AccessAssignmentExpr")}
<0> > Expr "." Id "=" Expr    -> Expr    {non-assoc, cons("DesignatorAssignmentExpr")}
<0> > {
  Bindings "=>" Expr                         -> Expr         {prefer, cons("FunExpr")}
  Id "=>" Expr                               -> Expr       {prefer, cons("IdFunExpr")}
  "implicit" Id "=>" Expr                    -> Expr {prefer, cons("ImplicitFunExpr")}
  "_" "=>" Expr                              -> Expr {prefer, cons("WildcardFunExpr")}
  "if" "(" NoLExpr ")" Expr                  -> Expr          {prefer, cons("IfExpr")}
  "if" "(" NoLExpr ")" Expr "else" Expr      -> Expr              {cons("IfElseExpr")}
  "if" "(" NoLExpr ")" Expr ";" "else" Expr  -> Expr              {cons("IfElseExpr")}
  "while" "(" NoLExpr ")" Expr               -> Expr               {cons("WhileExpr")}
  "try" Expr                                 -> Expr         {prefer, cons("TryExpr")}
  "try" Expr "catch" Expr                    -> Expr            {cons("TryCatchExpr")}
  "try" Expr "finally" Expr                  -> Expr          {cons("TryFinallyExpr")}
  "try" Expr "catch" Expr "finally" Expr     -> Expr     {cons("TryCatchFinallyExpr"),
                                                                          avoid}
  "do" Expr ";" "while" "(" Expr ")"         -> Expr             {cons("DoWhileExpr")}
  "do" Expr "while" "(" Expr ")"             -> Expr             {cons("DoWhileExpr")}
  "for" "(" EnumeratorSemi+ ")" Expr         -> Expr                 {cons("ForExpr")}
  "for" "{" EnumeratorSemi+ "}" Expr         -> Expr                 {cons("ForExpr")}
  "for" "(" EnumeratorSemi+ ")" "yield" Expr -> Expr            {cons("ForYieldExpr")}
  "for" "{" EnumeratorSemi+ "}" "yield" Expr -> Expr            {cons("ForYieldExpr")}
  "throw" Expr                               -> Expr               {cons("ThrowExpr")}
  "return" Expr?                             -> Expr              {cons("ReturnExpr"),
                                          layout("1.last.line == 2.first.line")}
  Id "=" Expr                              -> Expr {non-assoc, cons("AssignmentExpr")}
  Expr Ascription                          -> Expr     {avoid, cons("AscriptionExpr")}
}

context-free priorities
  Expr "." Id   -> Expr                                {avoid, cons("DesignatorExpr")}
  > PREFIX Expr -> Expr                                           {cons("PrefixExpr")}


%%%%% NO Layout %%%%%%
context-free priorities
{
  Literal                   -> NoLExpr                                  {prefer}
  "_"                       -> NoLExpr                          {cons("WildcardExpr")}
  NoLExpr ArgumentExprs     -> NoLExpr                               {cons("AppExpr")}
  NoLExpr BlockExpr         -> NoLExpr                          {cons("BlockAppExpr")}
  "(" {NoLExpr ","}* ")"    -> NoLExpr                             {cons("TupleExpr")}
  NoLExpr TypeArgs          -> NoLExpr                       {cons("TypeApplication")}
  Path                      -> NoLExpr
}

> {
  "new" ClassTemplate -> NoLExpr                        {prefer, cons("NewClassExpr")}
  "new" TemplateBody  -> NoLExpr                     {prefer, cons("NewTemplateExpr")}
  NoLExpr "_"         -> NoLExpr                      {left, cons("EtaExpansionExpr")}
  BlockExpr           -> NoLExpr
}

> PREFIX NoLExpr             -> NoLExpr                           {cons("PrefixExpr")}
> PREFIX NoLExpr             -> NoLExpr                           {cons("PrefixExpr")}
> {
  NoLExpr SPECIAL-OP NoLExpr        -> NoLExpr               {left, cons("InfixExpr")}
  NoLExpr RASSOC-SPECIAL-OP NoLExpr -> NoLExpr              {right, cons("InfixExpr")}
}
> {
  NoLExpr MULT-OP NoLExpr        -> NoLExpr                  {left, cons("InfixExpr")}
  NoLExpr RASSOC-MULT-OP NoLExpr -> NoLExpr                 {right, cons("InfixExpr")}
}
> {
  NoLExpr SUM-OP NoLExpr        -> NoLExpr                   {left, cons("InfixExpr")}
  NoLExpr RASSOC-SUM-OP NoLExpr -> NoLExpr                  {right, cons("InfixExpr")}
}
> {
  NoLExpr COLON-OP NoLExpr        -> NoLExpr                 {left, cons("InfixExpr")}
  NoLExpr RASSOC-COLON-OP NoLExpr -> NoLExpr                {right, cons("InfixExpr")}
}
> {
  NoLExpr CMPR-OP NoLExpr        -> NoLExpr                  {left, cons("InfixExpr")}
  NoLExpr RASSOC-CMPR-OP NoLExpr -> NoLExpr                 {right, cons("InfixExpr")}
}
> {
  NoLExpr BRACKET-OP NoLExpr        -> NoLExpr               {left, cons("InfixExpr")}
  NoLExpr RASSOC-BRACKET-OP NoLExpr -> NoLExpr              {right, cons("InfixExpr")}
}
> {
  NoLExpr AMPERSAND-OP NoLExpr        -> NoLExpr             {left, cons("InfixExpr")}
  NoLExpr RASSOC-AMPERSAND-OP NoLExpr -> NoLExpr            {right, cons("InfixExpr")}
}
> {
  NoLExpr CIRCUMFLEX-OP NoLExpr        -> NoLExpr            {left, cons("InfixExpr")}
  NoLExpr RASSOC-CIRCUMFLEX-OP NoLExpr -> NoLExpr           {right, cons("InfixExpr")}
}
> {
  NoLExpr BAR-OP NoLExpr        -> NoLExpr                   {left, cons("InfixExpr")}
  NoLExpr RASSOC-BAR-OP NoLExpr -> NoLExpr                  {right, cons("InfixExpr")}
}
> {
  NoLExpr LETTER-OP NoLExpr        -> NoLExpr                {left, cons("InfixExpr")}
  NoLExpr RASSOC-LETTER-OP NoLExpr -> NoLExpr               {right, cons("InfixExpr")}
}
> NoLExpr ASSIGN-OP NoLExpr     -> NoLExpr                   {left, cons("InfixExpr")}
> NoLExpr Id -> NoLExpr                                   {avoid, cons("PostfixExpr")}
> NoLExpr Id -> NoLExpr                                   {avoid, cons("PostfixExpr")}
> NoLExpr "match" "{" CaseClause+ "}" -> NoLExpr                   {cons("MatchExpr")}
> NoLExpr ArgumentExprs "=" NoLExpr   -> NoLExpr        {cons("AccessAssignmentExpr"),
                                                                      non-assoc}
<0> > NoLExpr "." Id "=" NoLExpr    -> NoLExpr      {cons("DesignatorAssignmentExpr"),
                                                                      non-assoc}
<0> > {
  Bindings "=>" NoLExpr              -> NoLExpr              {prefer, cons("FunExpr")}
  Id "=>" NoLExpr                    -> NoLExpr            {prefer, cons("IdFunExpr")}
  "implicit" Id "=>" NoLExpr         -> NoLExpr      {prefer, cons("ImplicitFunExpr")}
  "_" "=>" NoLExpr                   -> NoLExpr      {prefer, cons("WildcardFunExpr")}
  "if" "(" NoLExpr ")" NoLExpr       -> NoLExpr               {prefer, cons("IfExpr")}
  "if" "(" NoLExpr ")" NoLExpr
    "else" NoLExpr                   -> NoLExpr                   {cons("IfElseExpr")}
  "if" "(" NoLExpr ")" NoLExpr
    ";" "else" NoLExpr               -> NoLExpr                   {cons("IfElseExpr")}
  "while" "(" NoLExpr ")" NoLExpr    -> NoLExpr                    {cons("WhileExpr")}
  "try" NoLExpr                      -> NoLExpr              {prefer, cons("TryExpr")}
  "try" NoLExpr "catch" NoLExpr      -> NoLExpr                 {cons("TryCatchExpr")}
  "try" NoLExpr "finally" NoLExpr    -> NoLExpr               {cons("TryFinallyExpr")}
  "try" NoLExpr "catch" NoLExpr
    "finally" NoLExpr                -> NoLExpr   {avoid, cons("TryCatchFinallyExpr")}
  "do" NoLExpr ";" "while" "(" NoLExpr ")"      -> NoLExpr       {cons("DoWhileExpr")}
  "do" NoLExpr "while" "(" NoLExpr ")"          -> NoLExpr       {cons("DoWhileExpr")}
  "for" "(" EnumeratorSemi+ ")" NoLExpr         -> NoLExpr           {cons("ForExpr")}
  "for" "{" EnumeratorSemi+ "}" NoLExpr         -> NoLExpr           {cons("ForExpr")}
  "for" "(" EnumeratorSemi+ ")" "yield" NoLExpr -> NoLExpr      {cons("ForYieldExpr")}
  "for" "{" EnumeratorSemi+ "}" "yield" NoLExpr -> NoLExpr      {cons("ForYieldExpr")}
  "throw" NoLExpr                               -> NoLExpr         {cons("ThrowExpr")}
  "return" NoLExpr?                             -> NoLExpr        {cons("ReturnExpr")}
  Id "=" NoLExpr                        -> NoLExpr {non-assoc, cons("AssignmentExpr")}
  NoLExpr Ascription                    -> NoLExpr     {avoid, cons("AscriptionExpr")}
}

context-free priorities
NoLExpr "." Id   -> NoLExpr                            {avoid, cons("DesignatorExpr")}
> PREFIX NoLExpr -> NoLExpr                                       {cons("PrefixExpr")}


%%% Repeat Priorities in context-free syntax for correct PPTable generation %%%
context-free syntax
"_"                                        -> Expr              {cons("WildcardExpr")}
Expr ArgumentExprs                         -> Expr                   {cons("AppExpr"),
                                          layout("1.last.line == 2.first.line")}
Expr BlockExpr                             -> Expr              {cons("BlockAppExpr"),
                                  layout("2.first.line - 1.last.line < num(2)")}
"(" {NoLExpr ","}* ")"                     -> Expr                 {cons("TupleExpr")}
Expr TypeArgs                              -> Expr           {cons("TypeApplication")}
"new" ClassTemplate                        -> Expr      {prefer, cons("NewClassExpr")}
"new" TemplateBody                         -> Expr   {prefer, cons("NewTemplateExpr")}
Expr "_"                                   -> Expr    {left, cons("EtaExpansionExpr"),
                                          layout("1.last.line == 2.first.line")}
PREFIX Expr                                -> Expr        {prefer, cons("PrefixExpr")}
Expr SPECIAL-OP Expr                       -> Expr           {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr MULT-OP Expr                          -> Expr           {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr SUM-OP Expr                           -> Expr           {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr COLON-OP Expr                         -> Expr           {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr CMPR-OP Expr                          -> Expr           {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr BRACKET-OP Expr                       -> Expr           {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr AMPERSAND-OP Expr                     -> Expr           {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr CIRCUMFLEX-OP Expr                    -> Expr           {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr BAR-OP Expr                           -> Expr           {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr LETTER-OP Expr                        -> Expr           {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr RASSOC-SPECIAL-OP Expr                -> Expr          {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr RASSOC-MULT-OP Expr                   -> Expr          {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr RASSOC-SUM-OP Expr                    -> Expr          {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr RASSOC-COLON-OP Expr                  -> Expr          {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr RASSOC-CMPR-OP Expr                   -> Expr          {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr RASSOC-BRACKET-OP Expr                -> Expr          {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr RASSOC-AMPERSAND-OP Expr              -> Expr          {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr RASSOC-CIRCUMFLEX-OP Expr             -> Expr          {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr RASSOC-BAR-OP Expr                    -> Expr          {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr RASSOC-LETTER-OP Expr                 -> Expr          {right, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr ASSIGN-OP Expr                        -> Expr           {left, cons("InfixExpr"),
   layout("1.last.line == 2.first.line && 3.first.line - 2.last.line < num(2)")}
Expr Id                                    -> Expr        {avoid, cons("PostfixExpr"),
                                          layout("1.last.line == 2.first.line")}
Expr "match" "{" CaseClause+ "}" -> Expr                           {cons("MatchExpr")}
Expr ArgumentExprs "=" Expr      -> Expr     {non-assoc, cons("AccessAssignmentExpr")}
Expr "." Id "=" Expr             -> Expr {non-assoc, cons("DesignatorAssignmentExpr")}
Bindings "=>" Expr               -> Expr                     {prefer, cons("FunExpr")}
Id "=>" Expr                     -> Expr                   {prefer, cons("IdFunExpr")}
"implicit" Id "=>" Expr          -> Expr             {prefer, cons("ImplicitFunExpr")}
"_" "=>" Expr                    -> Expr             {prefer, cons("WildcardFunExpr")}
"if" "(" NoLExpr ")" Expr        -> Expr                      {prefer, cons("IfExpr")}
"if" "(" NoLExpr ")" Expr
  "else" Expr                    -> Expr                          {cons("IfElseExpr")}
"if" "(" NoLExpr ")" Expr ";"
  "else" Expr                    -> Expr                          {cons("IfElseExpr")}
"while" "(" NoLExpr ")" Expr            -> Expr                    {cons("WhileExpr")}
"try" Expr                              -> Expr              {prefer, cons("TryExpr")}
"try" Expr "catch" Expr                 -> Expr                 {cons("TryCatchExpr")}
"try" Expr "finally" Expr               -> Expr               {cons("TryFinallyExpr")}
"try" Expr "catch" Expr "finally" Expr  -> Expr   {avoid, cons("TryCatchFinallyExpr")}
"do" Expr ";" "while" "(" Expr ")"      -> Expr                  {cons("DoWhileExpr")}
"do" Expr "while" "(" Expr ")"          -> Expr                  {cons("DoWhileExpr")}
"for" "(" EnumeratorSemi+ ")" Expr         -> Expr                   {cons("ForExpr")}
"for" "{" EnumeratorSemi+ "}" Expr         -> Expr                   {cons("ForExpr")}
"for" "(" EnumeratorSemi+ ")" "yield" Expr -> Expr              {cons("ForYieldExpr")}
"for" "{" EnumeratorSemi+ "}" "yield" Expr -> Expr              {cons("ForYieldExpr")}
"throw" Expr                               -> Expr                 {cons("ThrowExpr")}
"return" Expr?                             -> Expr                {cons("ReturnExpr"),
                                          layout("1.last.line == 2.first.line")}
Id "=" Expr                              -> Expr   {non-assoc, cons("AssignmentExpr")}
Expr Ascription                          -> Expr       {avoid, cons("AscriptionExpr")}
Expr "." Id                              -> Expr       {avoid, cons("DesignatorExpr")}
PREFIX Expr                              -> Expr                  {cons("PrefixExpr")}

"_"                                    -> NoLExpr               {cons("WildcardExpr")}
Literal                                -> NoLExpr                       {prefer}
NoLExpr ArgumentExprs                  -> NoLExpr                    {cons("AppExpr")}
NoLExpr BlockExpr                      -> NoLExpr               {cons("BlockAppExpr")}
"(" {NoLExpr ","}* ")"                 -> NoLExpr                  {cons("TupleExpr")}
NoLExpr TypeArgs                       -> NoLExpr            {cons("TypeApplication")}
"new" ClassTemplate                    -> NoLExpr       {prefer, cons("NewClassExpr")}
"new" TemplateBody                     -> NoLExpr    {prefer, cons("NewTemplateExpr")}
NoLExpr "_"                            -> NoLExpr     {left, cons("EtaExpansionExpr")}
PREFIX NoLExpr                         -> NoLExpr         {prefer, cons("PrefixExpr")}
NoLExpr SPECIAL-OP NoLExpr             -> NoLExpr            {left, cons("InfixExpr")}
NoLExpr MULT-OP NoLExpr                -> NoLExpr            {left, cons("InfixExpr")}
NoLExpr SUM-OP NoLExpr                 -> NoLExpr            {left, cons("InfixExpr")}
NoLExpr COLON-OP NoLExpr               -> NoLExpr            {left, cons("InfixExpr")}
NoLExpr CMPR-OP NoLExpr                -> NoLExpr            {left, cons("InfixExpr")}
NoLExpr BRACKET-OP NoLExpr             -> NoLExpr            {left, cons("InfixExpr")}
NoLExpr AMPERSAND-OP NoLExpr           -> NoLExpr            {left, cons("InfixExpr")}
NoLExpr CIRCUMFLEX-OP NoLExpr          -> NoLExpr            {left, cons("InfixExpr")}
NoLExpr BAR-OP NoLExpr                 -> NoLExpr            {left, cons("InfixExpr")}
NoLExpr LETTER-OP NoLExpr              -> NoLExpr            {left, cons("InfixExpr")}
NoLExpr RASSOC-SPECIAL-OP NoLExpr      -> NoLExpr           {right, cons("InfixExpr")}
NoLExpr RASSOC-MULT-OP NoLExpr         -> NoLExpr           {right, cons("InfixExpr")}
NoLExpr RASSOC-SUM-OP NoLExpr          -> NoLExpr           {right, cons("InfixExpr")}
NoLExpr RASSOC-COLON-OP NoLExpr        -> NoLExpr           {right, cons("InfixExpr")}
NoLExpr RASSOC-CMPR-OP NoLExpr         -> NoLExpr           {right, cons("InfixExpr")}
NoLExpr RASSOC-BRACKET-OP NoLExpr      -> NoLExpr           {right, cons("InfixExpr")}
NoLExpr RASSOC-AMPERSAND-OP NoLExpr    -> NoLExpr           {right, cons("InfixExpr")}
NoLExpr RASSOC-CIRCUMFLEX-OP NoLExpr   -> NoLExpr           {right, cons("InfixExpr")}
NoLExpr RASSOC-BAR-OP NoLExpr          -> NoLExpr           {right, cons("InfixExpr")}
NoLExpr RASSOC-LETTER-OP NoLExpr       -> NoLExpr           {right, cons("InfixExpr")}
NoLExpr ASSIGN-OP NoLExpr              -> NoLExpr            {left, cons("InfixExpr")}
NoLExpr Id                             -> NoLExpr         {avoid, cons("PostfixExpr")}
NoLExpr Id                             -> NoLExpr         {avoid, cons("PostfixExpr")}
NoLExpr "match" "{" CaseClause+ "}"    -> NoLExpr                  {cons("MatchExpr")}
NoLExpr ArgumentExprs "=" NoLExpr      -> NoLExpr       {cons("AccessAssignmentExpr"),
                                                                      non-assoc}
NoLExpr "." Id "=" NoLExpr             -> NoLExpr   {cons("DesignatorAssignmentExpr"),
                                                                      non-assoc}
Bindings "=>" NoLExpr                  -> NoLExpr            {prefer, cons("FunExpr")}
Id "=>" NoLExpr                        -> NoLExpr          {prefer, cons("IdFunExpr")}
"implicit" Id "=>" NoLExpr             -> NoLExpr    {prefer, cons("ImplicitFunExpr")}
"_" "=>" NoLExpr                       -> NoLExpr    {prefer, cons("WildcardFunExpr")}
"if" "(" NoLExpr ")" NoLExpr                     -> NoLExpr   {prefer, cons("IfExpr")}
"if" "(" NoLExpr ")" NoLExpr "else" NoLExpr      -> NoLExpr       {cons("IfElseExpr")}
"if" "(" NoLExpr ")" NoLExpr ";" "else" NoLExpr  -> NoLExpr       {cons("IfElseExpr")}
"while" "(" NoLExpr ")" NoLExpr                  -> NoLExpr        {cons("WhileExpr")}
"try" NoLExpr                               -> NoLExpr               {cons("TryExpr")}
"try" NoLExpr "catch" NoLExpr               -> NoLExpr          {cons("TryCatchExpr")}
"try" NoLExpr "finally" NoLExpr             -> NoLExpr        {cons("TryFinallyExpr")}
"try" NoLExpr "catch" NoLExpr
  "finally" NoLExpr                         -> NoLExpr   {cons("TryCatchFinallyExpr")}
"do" NoLExpr ";" "while" "(" NoLExpr ")"      -> NoLExpr         {cons("DoWhileExpr")}
"do" NoLExpr "while" "(" NoLExpr ")"          -> NoLExpr         {cons("DoWhileExpr")}
"for" "(" EnumeratorSemi+ ")" NoLExpr         -> NoLExpr             {cons("ForExpr")}
"for" "{" EnumeratorSemi+ "}" NoLExpr         -> NoLExpr             {cons("ForExpr")}
"for" "(" EnumeratorSemi+ ")" "yield" NoLExpr -> NoLExpr        {cons("ForYieldExpr")}
"for" "{" EnumeratorSemi+ "}" "yield" NoLExpr -> NoLExpr        {cons("ForYieldExpr")}
"throw" NoLExpr                               -> NoLExpr           {cons("ThrowExpr")}
"return" NoLExpr?                             -> NoLExpr          {cons("ReturnExpr"),
                                          layout("1.last.line == 2.first.line")}
NoLExpr Ascription                    -> NoLExpr       {avoid, cons("AscriptionExpr")}
Id "=" NoLExpr                        -> NoLExpr   {non-assoc, cons("AssignmentExpr")}
NoLExpr "." Id                        -> NoLExpr       {avoid, cons("DesignatorExpr")}
PREFIX NoLExpr                        -> NoLExpr                  {cons("PrefixExpr")}


%%%%% Common %%%%%%
context-free syntax
"(" NoLExprs? ")"                           -> ArgumentExprs   {cons("ArgumentExprs")}
"(" (NoLExprs ",")? NoLExpr ":" "_" "*" ")" -> ArgumentExprs
                                               {prefer, cons("SequenceArgumentExprs")}

ArgumentExprs                  -> ArgumentExprsSeq
ArgumentExprs ArgumentExprsSeq -> ArgumentExprsSeq          {cons("ArgumentExprsSeq"),
                                          layout("1.last.line == 2.first.line")}

{NoLExpr ","}+ -> NoLExprs                                             {cons("Exprs")}

":" InfixType   -> Ascription                                 {cons("TypeAscription")}
":" Annotation+ -> Ascription                           {cons("AnnotationAscription")}
":" "_" "*"     -> Ascription                             {cons("SequenceAscription")}

Pattern1 "<-" Expr Guard?       -> Generator                       {cons("Generator")}
"val" Pattern1 "<-" Expr Guard? -> Generator                       {cons("Generator")}

"if" NoLExpr -> Guard                                                  {cons("Guard")}

Enumerator EOL  -> EnumeratorSemi                             {cons("EnumeratorSemi"),
                                         enforce-newline, longest-match, prefer}
Enumerator SEMI -> EnumeratorSemi              {longest-match, cons("EnumeratorSemi")}
Enumerator EOP  -> EnumeratorSemi       {longest-match, avoid, cons("EnumeratorSemi")}
Enumerator EOB  -> EnumeratorSemi       {longest-match, avoid, cons("EnumeratorSemi")}

Generator                    -> Enumerator
Guard                        -> Enumerator
Pattern1 "=" Expr            -> Enumerator                            {cons("ValDef")}
"val" Pattern1 "=" Expr      -> Enumerator                            {cons("ValDef")}

"case" Pattern Guard? "=>" CaseBlock -> CaseClause                {cons("CaseClause")}

"{" CaseClause+ "}" -> BlockExpr                               {cons("CaseBlockExpr")}
"{" Block "}"       -> BlockExpr                                   {cons("BlockExpr")}

Block              -> CaseBlock
CaseBlockStatSemi* -> CaseBlock                             {avoid, cons("CaseBlock")}

BlockStatSemi      -> CaseBlockStatSemi
BlockStat EOC      -> CaseBlockStatSemi              {avoid, cons("EOCBlockStatSemi")}

BlockStatSemi* ResultExpr -> Block                             {prefer, cons("Block")}
BlockStatSemi*            -> Block                                     {cons("Block")}

Bindings "=>" Block                       -> ResultExpr   {cons("BindingsResultExpr")}
"implicit" Id ":" CompoundType "=>" Block -> ResultExpr   {cons("ImplicitResultExpr")}
Id (":" CompoundType)? "=>" Block         -> ResultExpr     {cons("SimpleResultExpr")}
"_" (":" CompoundType)? "=>" Block        -> ResultExpr   {cons("WildcardResultExpr")}

BlockStat EOL   -> BlockStatSemi                               {cons("BlockStatSemi"),
                                         enforce-newline, longest-match, prefer}
BlockStat SEMI  -> BlockStatSemi                {longest-match, cons("BlockStatSemi")}
BlockStat EOB   -> BlockStatSemi         {longest-match, avoid, cons("BlockStatSemi")}
SEMI            -> BlockStatSemi

Import                             -> BlockStat
Expr                               -> BlockStat
Annotation* LocalModifier* TmplDef -> BlockStat     {prefer, cons("TmplDefBlockStat")}
Annotation* Def                    -> BlockStat                 {cons("DefBlockStat")}
Annotation* "implicit" Def         -> BlockStat         {cons("ImplicitDefBlockStat")}
Annotation* "lazy" Def             -> BlockStat             {cons("LazyDefBlockStat")}

TemplateStat SEMI -> TemplateStatSemi        {longest-match, cons("TemplateStatSemi")}
TemplateStat EOL  -> TemplateStatSemi                       {cons("TemplateStatSemi"),
                                         enforce-newline, longest-match, prefer}
TemplateStat EOB  -> TemplateStatSemi {longest-match, avoid, cons("TemplateStatSemi")}
SEMI              -> TemplateStatSemi

AnnotationSeq? Modifier* Def -> TemplateStat                 {cons("DefTemplateStat")}
AnnotationSeq? Modifier* Dcl -> TemplateStat                 {cons("DclTemplateStat")}
Import                       -> TemplateStat              {cons("ImportTemplateStat")}
Expr                         -> TemplateStat                {cons("ExprTemplateStat")}

Id (":" Type)?  -> Binding                                           {cons("Binding")}
"_" (":" Type)? -> Binding                                   {cons("WildCardBinding")}

"(" {Binding ","}* ")" -> Bindings                                  {cons("Bindings")}

"=" Expr -> Assignment                                            {cons("Assignment")}

module Scala-ClassesObjects

imports
Scala-BasicDeclsDefs
Scala-Expressions
Scala-Identifiers
Scala-Types
Scala-Whitespace

exports

context-free syntax
%% §5.1 - Templates
EarlyDefs? ClassParents TemplateBody? -> ClassTemplate         {cons("ClassTemplate")}
EarlyDefs? TraitParents TemplateBody? -> TraitTemplate         {cons("TraitTemplate")}

Constr WithAnnotType*    -> ClassParents                        {cons("ClassParents")}
AnnotType WithAnnotType* -> TraitParents                        {cons("TraitParents")}

"with" AnnotType         -> WithAnnotType                      {cons("WithAnnotType")}

Id Typed? "=>"       -> SelfType                                    {cons("SelfType")}
"this" ":" Type "=>" -> SelfType                                {cons("ThisSelfType")}
"_" ":" Type "=>"    -> SelfType                            {cons("WildcardSelfType")}

%% TODO: Nl
"{" SelfType TemplateStatSemi* "}" -> TemplateBody      {cons("SelfTypeTemplateBody"),
                                                                         prefer}
"{" TemplateStatSemi* "}"          -> TemplateBody              {cons("TemplateBody")}

%% §5.1.1 - Constructor Invocations
AnnotType ArgumentExprsSeq? -> Constr                                 {cons("Constr")}

%% §5.1.6 - Early Definitions
"{" EarlyDefSemi* "}" "with" -> EarlyDefs                          {cons("EarlyDefs")}

EarlyDef SEMI -> EarlyDefSemi                    {longest-match, cons("EarlyDefSemi")}
EarlyDef EOL  -> EarlyDefSemi                                   {cons("EarlyDefSemi"),
                                         enforce-newline, longest-match, prefer}
EarlyDef EOB  -> EarlyDefSemi             {longest-match, avoid, cons("EarlyDefSemi")}

AnnotationSeq? Modifier* PatVarDef -> EarlyDef                      {cons("EarlyDef")}


%% §5.2 - Modifiers
LocalModifier  -> Modifier
AccessModifier -> Modifier
"override"     -> Modifier                                  {cons("OverrideModifier")}

"abstract" -> LocalModifier                                 {cons("AbstractModifier")}
"final"    -> LocalModifier                                    {cons("FinalModifier")}
"sealed"   -> LocalModifier                                   {cons("SealedModifier")}
"implicit" -> LocalModifier                                 {cons("ImplicitModifier")}
"lazy"     -> LocalModifier                                     {cons("LazyModifier")}

"private" AccessQualifier?   -> AccessModifier               {cons("PrivateModifier")}
"protected" AccessQualifier? -> AccessModifier             {cons("ProtectedModifier")}

"[" Id "]"     -> AccessQualifier                            {cons("AccessQualifier")}
"[" "this" "]" -> AccessQualifier                              {cons("ThisQualifier")}


%% §5.3 - Class Definitions
"class" ClassDef -> TmplDef                                            {cons("Class")}

Morphism ConstrAnnotation*
  AccessModifier? ClassParamClauses? ClassTemplateOpt -> ClassDef   {cons("ClassDef"),
                                  layout("4.first.line - 1.last.line < num(2)")}

Id                  -> Morphism
Id TypeParamClause  -> Morphism                                    {cons("Polymorph")}

ClassParamClause                     -> ClassParamClauses
"(" "implicit" {ClassParam ","}+ ")" -> ClassParamClauses
                                            {prefer, cons("ImplicitClassParamClause")}
ClassParamClause ClassParamClauses   -> ClassParamClauses
            {layout("2.first.line - 1.last.line < num(2)"), cons("ClassParamClauses")}

"(" {ClassParam ","}* ")" -> ClassParamClause               {cons("ClassParamClause")}

Annotation* Id ":" ParamType Assignment?                 -> ClassParam
                                                                  {cons("ClassParam")}
Annotation* Modifier* "val" Id ":" ParamType Assignment? -> ClassParam
                                                               {cons("ValClassParam")}
Annotation* Modifier* "var" Id ":" ParamType Assignment? -> ClassParam
                                                               {cons("VarClassParam")}

"extends" ClassTemplate -> ClassTemplateOpt            {cons("ClassClassTemplateOpt")}
"extends" TemplateBody  -> ClassTemplateOpt         {cons("TemplateClassTemplateOpt")}
                        -> ClassTemplateOpt            {cons("EmptyClassTemplateOpt")}
TemplateBody            -> ClassTemplateOpt


%% §5.3.1 - Constructor Definitions
"this" ParamClauses "=" ConstrExpr -> FunDef                  {cons("ThisExprFunDef")}
"this" ParamClauses ConstrBlock    -> FunDef                 {cons("ThisBlockFunDef"),
                                  layout("3.first.line - 2.last.line < num(2)")}

"this" ArgumentExprsSeq -> SelfInvocation                     {cons("SelfInvocation")}
"this" BlockExpr        -> SelfInvocation                {cons("BlockSelfInvocation"),
                                  layout("2.first.line - 1.last.line < num(2)")}

SelfInvocation -> ConstrExpr
ConstrBlock    -> ConstrExpr

"{" SelfInvocation ";" BlockStatSemi* "}"  -> ConstrBlock        {cons("ConstrBlock")}
"{" SelfInvocation "}"                     -> ConstrBlock        {cons("ConstrBlock")}
"{" SelfInvocation BlockStatSemi+ "}"      -> ConstrBlock        {cons("ConstrBlock"),
                                  layout("3.first.line - 2.last.line > num(0)")}

%% §5.3.2 - Case Classes
"case" "class" ClassDef   -> TmplDef                               {cons("CaseClass")}

%% §5.3.3 - Traits
"trait" TraitDef -> TmplDef                                            {cons("Trait")}

Id TypeParamClause? TraitTemplateOpt -> TraitDef                    {cons("TraitDef")}

"extends" TraitTemplate -> TraitTemplateOpt            {cons("TraitTraitTemplateOpt")}
"extends" TemplateBody  -> TraitTemplateOpt         {cons("TemplateTraitTemplateOpt")}
                        -> TraitTemplateOpt            {cons("EmptyTraitTemplateOpt")}
TemplateBody            -> TraitTemplateOpt

%% §5.4 - Object Definitions
"case" "object" ObjectDef -> TmplDef                              {cons("CaseObject")}
"object" ObjectDef        -> TmplDef                                  {cons("Object")}

Id ClassTemplateOpt -> ObjectDef                                   {cons("ObjectDef")}

module Scala-BasicDeclsDefs

imports
Scala-ClassesObjects
Scala-Expressions
Scala-Identifiers
Scala-Types

exports

context-free syntax
%% Extracted to avoid optional lexical syntax:
%%     (":" Type)?
":" Type      -> Typed                                                 {cons("Typed")}
":" ParamType -> ParamTyped                                       {cons("ParamTyped")}

%% §4 - Basic Declarations and Definitions
PatVarDef      -> Def
TmplDef        -> Def


%% §4.1 - Value Declarations and Definitions
"val" ValDcl                         -> Dcl                        {cons("ValDclDcl")}
{Id ","}+ ":" Type                   -> ValDcl                        {cons("ValDcl")}
"val" PatDef                         -> PatVarDef                  {cons("ValPatDef")}
{Pattern2 ","}+ Typed? "=" Expr      -> PatDef                        {cons("PatDef")}


%% §4.2 - Variable Declarations and Definitions
"var" VarDcl               -> Dcl                                  {cons("VarDclDcl")}
"var" VarDef               -> PatVarDef                            {cons("VarPatDef")}
{Id ","}+ ":" Type         -> VarDcl                                  {cons("VarDcl")}
{Id ","}+ ":" Type "=" "_" -> VarDef                  {prefer, cons("WildcardVarDef")}
PatDef                     -> VarDef


%% §4.3 - Type Declarations and Type Aliases
"type" TypeDcl                                      -> Dcl        {cons("TypeDclDcl")}
Id TypeParamClause? LowerBoundType? UpperBoundType? -> TypeDcl       {cons("TypeDcl")}
"type" TypeDef                                      -> Def        {cons("TypeDefDef")}
Id TypeParamClause? "=" Type                        -> TypeDef       {cons("TypeDef")}


%% §.4.4 - Type Parameters
"[" {VariantTypeParam ","}+ "]" -> TypeParamClause           {cons("TypeParamClause")}

Annotation* TypeParam     -> VariantTypeParam               {cons("VariantTypeParam")}
Annotation* "+" TypeParam -> VariantTypeParam           {cons("PlusVariantTypeParam")}
Annotation* "-" TypeParam -> VariantTypeParam            {cons("NegVariantTypeParam")}

Id  TypeParamClause? LowerBoundType?
  UpperBoundType? TypeViewBound* TypeContextBound* -> TypeParam    {cons("TypeParam")}
"_" TypeParamClause? LowerBoundType?
  UpperBoundType? TypeViewBound* TypeContextBound* -> TypeParam
                                                           {cons("WildcardTypeParam")}

">:" Type -> LowerBoundType                                   {cons("LowerBoundType")}
"<:" Type -> UpperBoundType                                   {cons("UpperBoundType")}
"<%" Type -> TypeViewBound                                     {cons("TypeViewBound")}
":" Type  -> TypeContextBound                               {cons("TypeContextBound")}


%% §4.6 - Function Declarations and Definitions
"def" FunDcl                         -> Dcl                        {cons("FunDclDcl")}
FunSig ":" Type                      -> FunDcl                        {cons("FunDcl")}
"def" FunDef                         -> Def                        {cons("FunDefDef")}
FunSig Typed? "=" Expr               -> FunDef                        {cons("FunDef")}
Id TypeParamClause? ParamClauses?    -> FunSig                        {cons("FunSig"),
                                  layout("3.first.line - 1.last.line < num(2)")}
%% Annotations are allowed for function type parameters according to
%% scalac v2.10.0*, % so TypeParamClause is used here instead of
%% FunTypeParamClause
%% "[" {TypeParam ","}+ "]"         -> FunTypeParamClause {"FunTypeParamClause"}

ParamClause                     -> ParamClauses
"(" "implicit" {Param ","}+ ")" -> ParamClauses          {cons("ImplicitParamClause")}
ParamClause ParamClauses        -> ParamClauses                 {cons("ParamClauses"),
                                  layout("2.first.line - 1.last.line < num(2)")}

"(" {Param ","}* ")" -> ParamClause                              {cons("ParamClause")}

Annotation* Id ParamTyped? Assignment? -> Param                        {cons("Param")}

Type      -> ParamType
"=>" Type -> ParamType                                           {cons("ByNameParam")}
Type "*"  -> ParamType                                         {cons("RepeatedParam")}

%% §4.6.3 - Procedures
FunSig               -> FunDcl                                       {cons("ProcDcl")}
FunSig "{" Block "}" -> FunDef                                       {cons("ProcDef"),
                                  layout("2.first.line - 1.last.line < num(2)")}

%% §4.7 - Import Clauses
"import" {ImportExpr ","}+ -> Import                                  {cons("Import")}

StableId                     -> ImportExpr                        {cons("ImportExpr")}
StableId "." "_"             -> ImportExpr                {cons("WildcardImportExpr")}
StableId "." ImportSelectors -> ImportExpr               {cons("SelectorsImportExpr")}

"{" {ImportSelector ","}+ "}"         -> ImportSelectors     {cons("ImportSelectors")}
"{" {ImportSelector ","}+ "," "_" "}" -> ImportSelectors
                                                 {cons("ImportSelectorsWithWildcard")}
"{" "_" "}"                           -> ImportSelectors
                                                 {cons("OnlyWildcardImportSelectors")}

Id          -> ImportSelector                                 {cons("ImportSelector")}
Id "=>" Id  -> ImportSelector                           {cons("MappedImportSelector")}
Id "=>" "_" -> ImportSelector                         {cons("WildcardImportSelector")}

module Scala-Annotations

imports
Scala-Expressions
Scala-Types

exports

context-free syntax
"@" SimpleType ArgumentExprsSeq? -> Annotation                    {cons("Annotation"),
                                          layout("2.last.line == 3.first.line")}

"@" SimpleType ArgumentExprs? -> ConstrAnnotation           {cons("ConstrAnnotation"),
                                          layout("2.last.line == 3.first.line")}

Annotation               -> AnnotationSeq
Annotation AnnotationSeq -> AnnotationSeq                      {cons("AnnotationSeq"),
                                  layout("2.first.line - 1.last.line < num(2)")}

module Scala

imports
Scala-Annotations
Scala-BasicDeclsDefs
Scala-ClassesObjects
Scala-Expressions
Scala-Identifiers
Scala-Literals
Scala-Macros
Scala-PatternMatching
Scala-TopLevelDefinitions
Scala-Types
Scala-Whitespace

exports

context-free start-symbols
Annotation
Block
CompilationUnit
Dcl
Def
Expr
Id
Import
NoLExpr
Path
Pattern
StableId
TemplateBody
TemplateStat
TmplDef
Type
TypeParamClause

module org/sugarj/languages/Scala
imports Scala
	[ AMPERSAND-OP                          => SCALA-AMPERSAND-OP
	  ASSIGN-OP                             => SCALA-ASSIGN-OP
	  ASTERISK                              => SCALA-ASTERISK
	  AccessModifier                        => ScalaAccessModifier
	  AccessQualifier                       => ScalaAccessQualifier
	  AnnotType                             => ScalaAnnotType
	  Annotation                            => ScalaAnnotation
	  AnnotationSeq                         => ScalaAnnotationSeq
	  ArgumentExprs                         => ScalaArgumentExprs
	  ArgumentExprsSeq                      => ScalaArgumentExprsSeq
	  Ascription                            => ScalaAscription
	  Assignment                            => ScalaAssignment
	  BAR-OP                                => SCALA-BAR-OP
	  BLOCK-COMMENT                         => SCALA-BLOCK-COMMENT
	  BLOCK-COMMENT-PART                    => SCALA-BLOCK-COMMENT-PART
	  BRACKET-OP                            => SCALA-BRACKET-OP
	  Binding                               => ScalaBinding
	  Bindings                              => ScalaBindings
	  Block                                 => ScalaBlock
	  BlockExpr                             => ScalaBlockExpr
	  BlockStat                             => ScalaBlockStat
	  BlockStatSemi                         => ScalaBlockStatSemi
	  BooleanLiteral                        => ScalaBooleanLiteral
	  CHAR                                  => SCALA-CHAR
	  CHAR-ESCAPE-SEQ                       => SCALA-CHAR-ESCAPE-SEQ
	  CHAR-NO-DOUBLE-QUOTE                  => SCALA-CHAR-NO-DOUBLE-QUOTE
	  CIRCUMFLEX-OP                         => SCALA-CIRCUMFLEX-OP
	  CMPR-OP                               => SCALA-CMPR-OP
	  COLON-OP                              => SCALA-COLON-OP
	  CONST-ID                              => SCALA-CONST-ID
	  CONST-ID-OP                           => SCALA-CONST-ID-OP
	  CONST-ID-USS                          => SCALA-CONST-ID-USS
	  CONST-PLAIN-ID                        => SCALA-CONST-PLAIN-ID
	  CaseBlock                             => ScalaCaseBlock
	  CaseBlockStatSemi                     => ScalaCaseBlockStatSemi
	  CaseClause                            => ScalaCaseClause
	  ClassDef                              => ScalaClassDef
	  ClassParam                            => ScalaClassParam
	  ClassParamClause                      => ScalaClassParamClause
	  ClassParamClauses                     => ScalaClassParamClauses
	  ClassParents                          => ScalaClassParents
	  ClassQualifier                        => ScalaClassQualifier
	  ClassTemplate                         => ScalaClassTemplate
	  ClassTemplateOpt                      => ScalaClassTemplateOpt
	  CompilationUnit                       => ScalaCompilationUnit
	  CompoundType                          => ScalaCompoundType
	  Constr                                => ScalaConstr
	  ConstrAnnotation                      => ScalaConstrAnnotation
	  ConstrBlock                           => ScalaConstrBlock
	  ConstrExpr                            => ScalaConstrExpr
	  DECIMAL-NUMERAL                       => SCALA-DECIMAL-NUMERAL
	  DIGIT                                 => SCALA-DIGIT
	  DOUBLE-DOUBLE-QUOTE                   => SCALA-DOUBLE-DOUBLE-QUOTE
	  DOUBLE-QUOTE                          => SCALA-DOUBLE-QUOTE
	  Dcl                                   => ScalaDcl
	  Def                                   => ScalaDef
	  EOB                                   => SCALA-EOB
	  EOC                                   => SCALA-EOC
	  EOF                                   => SCALA-EOF
	  EOL                                   => SCALA-EOL
	  EOP                                   => SCALA-EOP
	  EXPONENT-PART                         => SCALA-EXPONENT-PART
	  EarlyDef                              => ScalaEarlyDef
	  EarlyDefSemi                          => ScalaEarlyDefSemi
	  EarlyDefs                             => ScalaEarlyDefs
	  Enumerator                            => ScalaEnumerator
	  EnumeratorSemi                        => ScalaEnumeratorSemi
	  ExistentialClause                     => ScalaExistentialClause
	  ExistentialDcl                        => ScalaExistentialDcl
	  ExistentialDclSemi                    => ScalaExistentialDclSemi
	  Expr                                  => ScalaExpr
	  FANCY-ID                              => SCALA-FANCY-ID
	  FLOAT-TYPE                            => SCALA-FLOAT-TYPE
	  FLOATING-POINT                        => SCALA-FLOATING-POINT
	  FunDcl                                => ScalaFunDcl
	  FunDef                                => ScalaFunDef
	  FunSig                                => ScalaFunSig
	  FunTypeParamClause                    => ScalaFunTypeParamClause
	  FunctionArgTypes                      => ScalaFunctionArgTypes
	  Generator                             => ScalaGenerator
	  Guard                                 => ScalaGuard
	  HEX-DIGIT                             => SCALA-HEX-DIGIT
	  HEX-NUMERAL                           => SCALA-HEX-NUMERAL
	  ICONST-ID                             => SCALA-ICONST-ID
	  ICONST-ID-OP                          => SCALA-ICONST-ID-OP
	  ICONST-ID-USS                         => SCALA-ICONST-ID-USS
	  ICONST-PLAIN-ID                       => SCALA-ICONST-PLAIN-ID
	  ID-REST                               => SCALA-ID-REST
	  IMULTI-LINE-PROCESSED-STRING-ELEMENT  => SCALA-IMULTI-LINE-PROCESSED-STRING-ELEMENT
	  INFIX-PATTERN-OP                      => SCALA-INFIX-PATTERN-OP
	  INTEGER                               => SCALA-INTEGER
	  IPLAIN-ID                             => SCALA-IPLAIN-ID
	  IVAR-ID                               => SCALA-IVAR-ID
	  IVAR-ID-OP                            => SCALA-IVAR-ID-OP
	  IVAR-ID-USS                           => SCALA-IVAR-ID-USS
	  IVAR-PLAIN-ID                         => SCALA-IVAR-PLAIN-ID
	  Id                                    => ScalaId
	  Import                                => ScalaImport
	  ImportExpr                            => ScalaImportExpr
	  ImportSelector                        => ScalaImportSelector
	  ImportSelectors                       => ScalaImportSelectors
	  InfixType                             => ScalaInfixType
	  KEYWORD                               => SCALA-KEYWORD
	  LETTER                                => SCALA-LETTER
	  LETTER-OP                             => SCALA-LETTER-OP
	  LOWER                                 => SCALA-LOWER
	  Literal                               => ScalaLiteral
	  LocalModifier                         => ScalaLocalModifier
	  LowerBoundType                        => ScalaLowerBoundType
	  MINUS-PREFIX                          => SCALA-MINUS-PREFIX
	  MULT-OP                               => SCALA-MULT-OP
	  MULTI-LINE-CHARS                      => SCALA-MULTI-LINE-CHARS
	  MULTI-LINE-PROCESSED-STRING-ELEMENT   => SCALA-MULTI-LINE-PROCESSED-STRING-ELEMENT
	  Modifier                              => ScalaModifier
	  Morphism                              => ScalaMorphism
	  NL                                    => SCALA-NL
	  NON-ZERO-DIGIT                        => SCALA-NON-ZERO-DIGIT
	  NoLExpr                               => ScalaNoLExpr
	  NoLExprs                              => ScalaNoLExprs
	  OCTAL-DIGIT                           => SCALA-OCTAL-DIGIT
	  OCTAL-NUMERAL                         => SCALA-OCTAL-NUMERAL
	  OP                                    => SCALA-OP
	  OP-CHAR                               => SCALA-OP-CHAR
	  ObjectDef                             => ScalaObjectDef
	  PLAIN-ID                              => SCALA-PLAIN-ID
	  PREFIX                                => SCALA-PREFIX
	  PRINTABLE                             => SCALA-PRINTABLE
	  PROCESSED-STRING                      => SCALA-PROCESSED-STRING
	  PROCESSED-STRING-ELEMENT              => SCALA-PROCESSED-STRING-ELEMENT
	  PROCESSING                            => SCALA-PROCESSING
	  PROCESSING-ELEMENT                    => SCALA-PROCESSING-ELEMENT
	  PackageDeclarationSemi                => ScalaPackageDeclarationSemi
	  PackageObject                         => ScalaPackageObject
	  Packaging                             => ScalaPackaging
	  Param                                 => ScalaParam
	  ParamClause                           => ScalaParamClause
	  ParamClauses                          => ScalaParamClauses
	  ParamType                             => ScalaParamType
	  ParamTyped                            => ScalaParamTyped
	  PatDef                                => ScalaPatDef
	  PatVarDef                             => ScalaPatVarDef
	  Path                                  => ScalaPath
	  PathElem                              => ScalaPathElem
	  Pattern                               => ScalaPattern
	  Pattern1                              => ScalaPattern1
	  Pattern2                              => ScalaPattern2
	  Pattern3                              => ScalaPattern3
	  Patterns                              => ScalaPatterns
	  QualId                                => ScalaQualId
	  RASSOC-AMPERSAND-OP                   => SCALA-RASSOC-AMPERSAND-OP
	  RASSOC-BAR-OP                         => SCALA-RASSOC-BAR-OP
	  RASSOC-BRACKET-OP                     => SCALA-RASSOC-BRACKET-OP
	  RASSOC-CIRCUMFLEX-OP                  => SCALA-RASSOC-CIRCUMFLEX-OP
	  RASSOC-CMPR-OP                        => SCALA-RASSOC-CMPR-OP
	  RASSOC-COLON-OP                       => SCALA-RASSOC-COLON-OP
	  RASSOC-LETTER-OP                      => SCALA-RASSOC-LETTER-OP
	  RASSOC-MULT-OP                        => SCALA-RASSOC-MULT-OP
	  RASSOC-SPECIAL-OP                     => SCALA-RASSOC-SPECIAL-OP
	  RASSOC-SUM-OP                         => SCALA-RASSOC-SUM-OP
	  RefineStat                            => ScalaRefineStat
	  RefineStatSemi                        => ScalaRefineStatSemi
	  Refinement                            => ScalaRefinement
	  ResultExpr                            => ScalaResultExpr
	  SEMI                                  => SCALA-SEMI
	  SLASH                                 => SCALA-SLASH
	  SPECIAL-OP                            => SCALA-SPECIAL-OP
	  STRING                                => SCALA-STRING
	  STRING-ELEMENT                        => SCALA-STRING-ELEMENT
	  SUM-OP                                => SCALA-SUM-OP
	  SYMBOL                                => SCALA-SYMBOL
	  SelfInvocation                        => ScalaSelfInvocation
	  SelfType                              => ScalaSelfType
	  SimplePattern                         => ScalaSimplePattern
	  SimpleType                            => ScalaSimpleType
	  StableId                              => ScalaStableId
	  StableIdElem                          => ScalaStableIdElem
	  TemplateBody                          => ScalaTemplateBody
	  TemplateStat                          => ScalaTemplateStat
	  TemplateStatSemi                      => ScalaTemplateStatSemi
	  TmplDef                               => ScalaTmplDef
	  TopStat                               => ScalaTopStat
	  TopStatSemi                           => ScalaTopStatSemi
	  TraitDef                              => ScalaTraitDef
	  TraitParents                          => ScalaTraitParents
	  TraitTemplate                         => ScalaTraitTemplate
	  TraitTemplateOpt                      => ScalaTraitTemplateOpt
	  Type                                  => ScalaType
	  TypeArgs                              => ScalaTypeArgs
	  TypeBounds                            => ScalaTypeBounds
	  TypeContextBound                      => ScalaTypeContextBound
	  TypeDcl                               => ScalaTypeDcl
	  TypeDef                               => ScalaTypeDef
	  TypeParam                             => ScalaTypeParam
	  TypeParamClause                       => ScalaTypeParamClause
	  TypeViewBound                         => ScalaTypeViewBound
	  Typed                                 => ScalaTyped
	  UNICODE-ESCAPE                        => SCALA-UNICODE-ESCAPE
	  UPPER                                 => SCALA-UPPER
	  UpperBoundType                        => ScalaUpperBoundType
	  VAR-ID                                => SCALA-VAR-ID
	  VAR-ID-OP                             => SCALA-VAR-ID-OP
	  VAR-ID-USS                            => SCALA-VAR-ID-USS
	  VAR-PLAIN-ID                          => SCALA-VAR-PLAIN-ID
	  ValDcl                                => ScalaValDcl
	  VarDcl                                => ScalaVarDcl
	  VarDef                                => ScalaVarDef
	  VariantTypeParam                      => ScalaVariantTypeParam
	  With                                  => ScalaWith
	  WithAnnotType                         => ScalaWithAnnotType ]
